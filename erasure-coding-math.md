# Erasure Coding 수학적 원리

## Reed-Solomon 코드 기반

MinIO는 Reed-Solomon 알고리즘을 사용하여 Erasure Coding을 구현합니다.

### 기본 수식

**N+K 구성에서:**
- N = 데이터 조각 수
- K = 패리티 조각 수
- 총 조각 수 = N + K
- 최대 K개 조각 손실까지 복구 가능

### 현재 MinIO 설정 (3 드라이브)

```
구성: 2+1 (N=2, K=1)
총 드라이브: 3개
장애 허용: 1개 드라이브
저장 효율성: 2/3 = 66.7%
오버헤드: 1/3 = 33.3%
```

### 용량 계산

**원본 데이터가 1GB일 때:**
```
데이터 조각: 1GB ÷ 2 = 500MB × 2개 = 1GB
패리티 조각: 500MB × 1개 = 500MB
총 필요 용량: 1GB + 500MB = 1.5GB
효율성: 1GB ÷ 1.5GB = 66.7%
```

## 다른 구성 예시

### 4 드라이브 구성 (2+2)
```
데이터 조각: 2개
패리티 조각: 2개
장애 허용: 2개 드라이브
효율성: 50%
```

### 6 드라이브 구성 (4+2)
```
데이터 조각: 4개
패리티 조각: 2개
장애 허용: 2개 드라이브
효율성: 66.7%
```

### 8 드라이브 구성 (4+4)
```
데이터 조각: 4개
패리티 조각: 4개
장애 허용: 4개 드라이브
효율성: 50%
```

## 복구 과정

### 1개 드라이브 장애 시 (현재 설정)
```
정상 상태: [D1] [D2] [P1]
장애 발생: [D1] [X]  [P1]

복구 과정:
1. D1과 P1을 읽음
2. XOR 연산으로 D2 계산
3. D2 = D1 ⊕ P1
4. 새 드라이브에 D2 복구
```

### 패리티 계산 예시
```
D1 = 10110011 (데이터 1)
D2 = 11001100 (데이터 2)
P1 = 01111111 (D1 ⊕ D2)

D2 장애 시:
D2 = D1 ⊕ P1
   = 10110011 ⊕ 01111111
   = 11001100 (복구됨)
```

## 성능 영향

### 읽기 성능
- **정상 시**: 모든 드라이브에서 병렬 읽기
- **장애 시**: 남은 드라이브에서 재계산

### 쓰기 성능
- **데이터 쓰기**: N개 드라이브에 병렬 쓰기
- **패리티 계산**: CPU에서 XOR 연산
- **패리티 쓰기**: K개 드라이브에 쓰기

## 최적 구성 가이드

### 소규모 환경 (3-6 드라이브)
```
3 드라이브: 2+1 (권장)
4 드라이브: 2+2 (높은 보호)
6 드라이브: 4+2 (균형)
```

### 대규모 환경 (8+ 드라이브)
```
8 드라이브:  4+4 (높은 보호)
12 드라이브: 8+4 (균형)
16 드라이브: 12+4 (높은 효율성)
```

## 실제 사용 시나리오

### 웹 서비스 (읽기 중심)
- 권장: 높은 효율성 구성 (8+4, 12+4)
- 이유: 저장 비용 절약, 읽기 성능 우수

### 백업 시스템 (안정성 중심)
- 권장: 높은 보호 구성 (4+4, 6+6)
- 이유: 데이터 손실 위험 최소화

### 개발/테스트 환경
- 권장: 최소 구성 (2+1, 4+2)
- 이유: 리소스 절약, 빠른 복구
```
