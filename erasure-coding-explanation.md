# Erasure Coding 상세 설명

## 기본 개념

Erasure Coding은 **N+K** 방식으로 작동합니다:
- **N**: 원본 데이터 조각 수 (Data Shards)
- **K**: 패리티 조각 수 (Parity Shards)
- **총 조각 수**: N + K

## 예시: 4+2 Erasure Coding

```
원본 파일 (1MB)
     ↓
┌─────────────────────────────────────┐
│ 데이터를 4개 조각으로 분할           │
└─────────────────────────────────────┘
     ↓
┌────┬────┬────┬────┐
│ D1 │ D2 │ D3 │ D4 │  ← 데이터 조각 (각 250KB)
└────┴────┴────┴────┘
     ↓
┌────┬────┬────┬────┬────┬────┐
│ D1 │ D2 │ D3 │ D4 │ P1 │ P2 │  ← 패리티 조각 2개 추가
└────┴────┴────┴────┴────┴────┘

총 6개 조각 중 최대 2개까지 손실되어도 복구 가능!
```

## MinIO의 Erasure Coding

### 현재 설정 분석
- **3개 드라이브**: EC:1 (2+1 구성)
- **Erasure Stripe Size**: 3
- **데이터 보호**: 1개 드라이브 장애까지 허용

```
3개 드라이브 구성:
┌─────────┬─────────┬─────────┐
│ Drive 1 │ Drive 2 │ Drive 3 │
│   D1    │   D2    │   P1    │  ← 2개 데이터 + 1개 패리티
└─────────┴─────────┴─────────┘

장애 시나리오:
- Drive 1 실패 → D2 + P1으로 D1 복구 가능
- Drive 2 실패 → D1 + P1으로 D2 복구 가능  
- Drive 3 실패 → D1 + D2로 P1 복구 가능
```

## 장점과 단점

### ✅ 장점
1. **공간 효율성**: 복제보다 적은 저장공간 사용
2. **데이터 보호**: 계산된 수만큼의 장애 허용
3. **성능**: 읽기 시 병렬 처리 가능
4. **확장성**: 드라이브 수에 따라 보호 수준 조정

### ❌ 단점
1. **CPU 사용량**: 인코딩/디코딩 시 계산 필요
2. **복구 시간**: 장애 시 재계산 필요
3. **복잡성**: 구현과 관리가 복잡
4. **최소 드라이브**: 최소 3개 이상 필요

## 다양한 EC 구성 예시

### 소규모 (3-6 드라이브)
```
3 드라이브: 2+1 (33% 오버헤드, 1 드라이브 장애 허용)
4 드라이브: 2+2 (50% 오버헤드, 2 드라이브 장애 허용)
6 드라이브: 4+2 (33% 오버헤드, 2 드라이브 장애 허용)
```

### 대규모 (8-16 드라이브)
```
8 드라이브:  4+4 (50% 오버헤드, 4 드라이브 장애 허용)
12 드라이브: 8+4 (33% 오버헤드, 4 드라이브 장애 허용)
16 드라이브: 12+4 (25% 오버헤드, 4 드라이브 장애 허용)
```

## 복제 vs Erasure Coding 비교

| 방식 | 저장 효율성 | 장애 허용 | CPU 사용 | 복구 속도 |
|------|-------------|-----------|----------|-----------|
| **복제 (3-way)** | 33% | 2 노드 | 낮음 | 빠름 |
| **EC (4+2)** | 67% | 2 노드 | 높음 | 보통 |
| **EC (8+4)** | 75% | 4 노드 | 높음 | 느림 |

## 실제 계산 예시

### 1TB 데이터 저장 시:

**3-way 복제:**
```
필요 용량: 1TB × 3 = 3TB
효율성: 33%
장애 허용: 2개 노드
```

**4+2 Erasure Coding:**
```
필요 용량: 1TB × 1.5 = 1.5TB
효율성: 67%
장애 허용: 2개 노드
```

**8+4 Erasure Coding:**
```
필요 용량: 1TB × 1.33 = 1.33TB
효율성: 75%
장애 허용: 4개 노드
```
